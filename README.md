### 做搭建-如何进行模块化设计

![页面搭建](/assets/page-build.png)

有时候组件和模块是一个不太好区分的概念，特别是在前端领域，大家对于功能、方法的划分粒度都有各自的理解。

在Angular里，module是一些类、函数或者值的集合。component则更像一个区块，比如某一段负责渲染模板到html的代码，多个component可以组成一个app。module之间可以相互引用，module也可以被component引用。

其实在Web标准里，也可以看到一些相同的思路，比如ESM(EcmaScript modules)和Web Component，分别归属于ECMAScript规范和W3C规范。在极简的场景下，module负责提供一些方法，component负责渲染到页面上。

比如一个React Component发布到npm就是一个React module。在搭建的场景下，组件和模块有一定的差异性：

* 组件：一个react component或者node.js module，在搭建体系下，都是一个组件；
* 模块：模块是组成页面的最小结构单位，一个模块会包含模板（jsx、xtpl等等）、样式（css）、脚本逻辑、数据描述（data-schema）、模拟数据（mock-data）、表单描述（form-schema）、数据逻辑（faas-function）、依赖的描述（deps）等，一个模块甚至可以承接一个页面的逻辑。
 * 组件加上数据描述，就是一个模块；

以下是一个模块的生产流程：

![模块生产流程](/assets/page-build1.png)

### 一、从组件到模块

原则上所有npm上的module，都应该低成本的引用。实际上，低成本本身确是一个很大的挑战。从研发到线上渲染，必须思考和解决下面的问题：

1、模块如何引用组件？
2、如何合理引入npm的资源？
3、如何引入和编译本地文件系统里的文件？
4、如何渲染一个页面？

### 一、如何解决研发问题

#### 1.1 模块、组件之间的引用

模块加载器是前端工程里非常重要的一部分。加载器本质上就是通过一个去中心化的引用关系来描述细粒度模块之间的依赖，开发者使用模块A的时候，只需要声明依赖模块A，而模块A本身依赖了模块B，是在模块A自己内部管理的。在最终浏览器端，加载器把一个个引用关系进行合并，最后用合并后的引用关系表来生成一串combo url。

引用关系实际对应的就是一个schema文件

```js
// xxx.json
{
  modules: {
    one: {
      async: false,
      fullpath: './one.js'
    },
    two: {
      async: false,
      fullpath: './two.js',
      requires: [ 'one' ]
    }
  }
}
```

因为有一份这样的依赖描述，也可以通过同名取最新版本的策略，来做到同名模块只会加载一次，一定程度上解决js体系过大的问题。同时，如果开发者有能力或者有一个好的策略对combo url进行管理，是可以做到多页面之间共享资源缓存的，提升全链路的用户体验。

这种依赖关系的设计方案，可以在服务端去重输出代码bundle。

![模块、组件之间的引用](/assets/fe-module.png)

#### 1.2 如何引入npm的资源

早期，npm上还没有成熟的前端模块托管方案（那个时候还是browsify盛行的时代），所有的组件、模块都需要发布到指定的一个源下。

随着webpack时代的到来，把前端组件发布到npm已经是托管的最佳实践。对构建依赖较小，基本上只是babel + CMD wrap

#### 1.3 如何引入和编译本地文件系统里的文件

为了维护方便，组件内部也会对文件进行拆分，组件src目录下可能会有比较复杂的文件目录结构，在原有的体系下，每个文件都会在xxx.json里生成一份module的声明。随着业务复杂度的提升，以及搭建场景的不可控，仅一个页面的合并后的xxx.json文件大小可能达到几十kb。

为了对文件进行合理的合并，对单个组件的构建引入了webpack，维护时可以是多个文件，对外暴露接口的时候单一文件，有点类似package.json里main字段的作用。为了避免webpack把package.json dependences里声明的依赖都打包到组件内部，构建器里会维护一份白名单，可以直接通过依赖关系引用，而不需要打包到组件bundle内部。

#### 1.4 如何渲染页面

统一提供一个页面渲染引擎，一个页面发布到渲染服务器上，实际只是发布了页面和组件、模块之间的引用关系，真正渲染的时候进行一次实时的“构建”。这里原本应该用“组装”这个词，但是随着端侧渲染方案的不断升级，渲染服务器已经提供了超出纯粹组装的能力，更像是一个实时的构建器。

![渲染源站](/assets/render-page.png)

开发者可以选择在服务端模板引用一个组件

```js
{{require(["/xxx/index.css"])}}
```

这样就会在页面文档结构里插入一段script
也可以选择在浏览器端加载一个组件：

```js
let customEvent = require("custom-event/index");
```

这样的话，如果这个组件没有在引用之前加载，就会通过异步脚本的方式把这个模块加载进来。
而渲染服务器提供了丰富的placeholder能力来满足各种不同的模块内容输出方式。

最典型的就是js的输出能力，比如placeholder("js")

默认选项`placeholder("js", noTag=false,needCalculate=false)`
计算页面的js资源依赖。

noTag: 选项允许不直接生成script标签，而是输出依赖的combouri，再由前端异步载入JS资源；
needCalculate: 开启后会计算依赖的依赖，默认不开启时只会解析一层依赖。

而placeholder("native")主要用于native场景，和js类似，不同的是native下会把依赖的JS资源的内容直接输出，而不是输出combouri的链接。

### 二、带来的问题

#### 2.1 页面数量带来的问题

当你的业务多，页面数量也多，每周参与搭建的角色很多人，线上活跃页面数上万个的时候，并且因为业务域存在一些管理，统一的诉求，一批页面之间存在共享的区块、模板、片段来保证批量生效。

页面数量大，不是让开发者简单开发几个应用仓库就可以满足。整个工程体系的复杂度也不是在构建本身的复杂，而是在资源管理上，所以也不是选择webpack或者不选择webpack可以解决的。

原来一个实体页面+多份数据来实现一批页面的方式，是一个非常不错的实践，本质上就是通过页面模板的能力，一方面约束运营或产品可用的模块，另一方面模板本身和应用已经有一些相似点，对模板的优化可以解决很多线上渲染时难以解决的问题。

#### 2.2 开源组件本身带来的风险

因为npm本身相对还是比较自由，大部分开发同学还是依赖自己的判断在使用大量的开源组件，可能是node端，也可能是消费者端，但是自由背后还是有蛮多的安全风险，比如之前出现的event-stream模块加入了盗取比特币钱包的代码，以及近期purescript发现有恶意代码，以及可能的开源组件带来的版权风险。盲目使用开源组件的风险远比想象的大，需要进行安全生产扫描。

